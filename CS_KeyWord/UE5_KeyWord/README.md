# 언리얼 엔진 5 이론 및 키워드 정리 언리얼 엔진 5 이론 및 키워드 정리

언리얼 엔진 키워드를 정리하는 곳입니다 

[Unreal Engine5 Docs](https://dev.epicgames.com/documentation/ko-kr/unreal-engine/unreal-engine-5-7-documentation)

--------------------------------------------------------------------------------

1. 좌표계
  - 유니티, DX, UE5등 왼손 좌표계 사용, 다만 언리얼 엔진은 **Z축이 위** <br>
  -  x축 Roll, y축 Pitch, z축 Yaw

UE5 좌표계 및 다양한 그래픽스 좌표계

<img src="https://github.com/VidanSilk/CS-Study/blob/main/CS_KeyWord/_img/3DCoordinateSystems.png"></img>

2. BluePrint / C++
  - **BluePrint**
      + 블루프린트는 에디터에서 노드 기반 인터페이스를 통해 게임 플레이 요소를 만들어주는 개념
      + 스크립팅 - 행동을 보다 손쉽게 정의 가능  
      + 빠른 반복 작업- 블루프린트 클래스를 더 빠르게 생성, 수정, 컴파일 및 테스트가 가능해서 프로토타이핑에 적합
      + 폭 넓은 접근성 - DataFlow가 시가적으로 표현되어, 쉽게 이해 가능하고, 진입 장벽이 낮음.
      + 향상된 검색 기능 - 쉽게 API, 에셋 레퍼런스를 검색하고 포함 가능
      + 안전한 메모리 모델 - 크래시를 방지할 수 있는 안전한 메모리 모델을 갖춤 
      + 단점 : 추가 기능이나 새로운걸 만들 때는, 기능을 제공 하지 않은 경우가 있음. 

      + [BluePrint Docs](https://dev.epicgames.com/documentation/ko-kr/unreal-engine/introduction-to-blueprints-visual-scripting-in-unreal-engine)
  
  - **C++**
      + 빠른 런타임 - 블루프린트 로직보다 훨씬 빠름, 쉽게 빌드 가능 
      + 명확한 디자인이 가능 - C++에서 변수나 함수를 노출하면, 세밀한 제어를 통해 원하는걸 정확히 노출할 수 있고, 특정 함수/변수를 보호하고 클래스의 공식 API를 만들 수 있음. 즉, 지나치게 크고 따라잡기 어려운 블루프린트를 만들지 않아도 됨.
      + 광범위한 엑세스 - UE의 로우 레벨 함수 기능에 접근 가능 
      + 폭넓은 확장성 - 외부 시스템 및 라이브러리를 생성하고 인터페이싱 가능, 대규모 블루프린트 그래프와 비교하여 보다 쉽게 수정할 수 있음 
      + 강력한 제어 - 시스템, 리소스 및 복잡한 알고리즘에 대한 로우 레벨 제어 가능 
      + 원활한 협업 - 텍스트로 저장되기 때문에, 프로젝트 간의 비교, 병합 및 공유가 쉬움 
      + 뛰어난 디버깅 - 블루프린트 디버거 보다 더 강력한 디버깅 툴이 존재 

C++ 클래스를 블루프린트로 확장시켜 새로운 게임플레이 클래스를 코드로 구성하면, 레벨 디자이너는 이것을 기반으로 블루프린트를 통해 작업 및 변경이 가능함. <br>
C++ 클래스와 블루프린트 시스템간의 상화작용에 영향을 끼치는 지정자가 여러가지가 있음. 

3. UObject
  - C++로 class를 작성하면 UClass가 붙는데, UHT(Unreal Header Tool) 코드를 분석 <br>
  - 엔진 실행시, 분석한걸 토대로 리플랙션 데이터를 통해 CDO(Class Default Object)를 UObject로 인스턴스(객체)를 만들어주고 CDO복사해서 동적으로 사용하는 시스템.
  - 주기적으로 리플랙션에서 사용하지 않는 Object들은 GC(Garbage Collection)이 메모리 정리 해줌.
  
4. UHT / UBT
   
빌드를 시작하면 UBT가 실행되고, UBT은 C++ 컴파일러 실행전에 UHT를 실행하는데, UHT은 헤더 파일을 Parsing하고 UGameplayAbility_AutoAttack.generated.h,UGameplayAbility_AutoAttack.gen.cpp에 UPROPERTY, UFUNCTION, UCLASS매크로 선언된 정보들을 저장하는 역할을 수행 <br>
이 과정이 끝나면 UHT의 작업은 끝나게 되고, 일반 C++컴파일러가 UHT이 생성한 코드를 포함해서 C++컴파일을 수행 

   - **UHT(Unreal Header Tool)**
     + C++ 코들을 컴파일 하기전에 모든 헤더파일들을 순회하면서, 언리얼 리플렉션 시스템에 필요한 정보을 읽어들 후, .generate.h 파일과 gen.cpp파일을 Intermediate폴더에 생성하는 소프트웨어
     + 자체적으로 리플렉션 시스템을 구현하기 위해 UCLASS(),UPROPERTY(),UFUNCTION() 등의 매크로를 사용하고, 이 매크로를 해석해서 C++ 컴파일러가 알아들을 수 있게 코드를 생성(.generate.h, .gen.cpp)해주는 작업. 
       
   - **UBT(Unreal Build Tool)**
     + Uproject, Target.cs, Build.cs를 읽어서 어떻게 빌드할지 정함
     + UBT가 UHT를 실행해서 모든 헤더파일을 읽어서 언리얼 매크로들(UClass, UFuntion 등....)을 전부 다 찾아서, 이 정보를 바탕으로 리플랙션 시스템을 사용할 수 있게 컴파일러가 인식할 수 있게 .generated.h 파일을 생성
     + UBT가 C++ 컴파일러를 호출해서 캄파일 및 UHT가 만든 .generated.h 코드를 합쳐 컴파일하고, 이 결과물이 Binaries폴더에 exe랑 dll로 나옴.
     + 바이너리가 실행되면 엔진 또는 게임이 메모리에 올라가서, 모든 생성된 언리얼 오브젝트들 클래스 별로 각 기본 CDO가 메모리에 등록된다.
     + 참고로 **.generated.h는 항상 가장 마지막 밑에 include**해야한다. 아니면 인식이 제대로 안되어, 에러가 발생한다.

5. Uneral Server / Unreal NetWork

일단 클라이언트 프로그래머가 언리얼 네티워크를 안다고 서버 프로그래머가 되는 것이 아니다. 클라 입장에서 서버를 공부하는 것으로, 클라가 하는 일들 중에서 '서버로 ~ 값이 변경 되었다고' 알려주는 것이다. 언리얼 네트워크는 일단 TCP로 구현 되어있다. <br>
다만, 일반적인 TCP 방식이 아닌 Replicate라는 시스템을 도입하였다. 그전에, 기본 네트워크 부터 알아보는 것이 좋을 것 같아서, OSI 7계층과 TCP/IP 4계층 프로토콜에 대해 설명하겠다. 

<img src="https://github.com/VidanSilk/CS-Study/blob/main/CS_KeyWord/_img/Osi7LayerandTCPIPImg.jpg" width="400" height="500"></img>

  - OSI 7계층
    1. 물리(Physical) 계층 → 주로, 전기적, 기계적 혹은 기능적인 특성을 이용해 통신 케이블로 데이터를 전송하는 곳으로, 통신 단위는 bit이다. 단순히 전송하기 때문에, 데이터가 무엇인지? 혹은 오류가 있는지 신경 쓰지 않는다. 대표적인 장비로 케이블, 리피터, 허브등이 있다. 
    2. 데이터 링크(DataLink) 계층 → 물리계층을 통해 송순신되는 정보의 오류와 흐름을 관리하여, 안전한 정보의 전달을 수행하는 역할을 한다. 즉, 통신에서의 오류도 찾아주고 재전송을 한다. 이 계층에서는 MAC 주소를 가지고 통신을 하고, 단위는 Frame이다. 대표적인 장비로 브릿지, 스위치가 있다.  정리하자면 브릿지나 스위치 장비를 통해 MAC 주소를 가지고 물리계층에서 받은 정보를 전달한다. 
    3. 네트워크(NetWork) 계층 → 데이터를 목적지까지 빠르고 안전하게 전달하는 기능(라우팅)을 한다. 네트워크 계층에서는 경로를 선택하고, 주소를 정하고 경로에 따라 패킷을 전달해주며, 라우터가 대표적인 장비이다. 여러 개의 노드를 거칠 때마다 경로를 찾아주는 역할을 하는 계층이기에, 다양한 길이의 데이터를 네트워크들을 통해 전달되고, 그 과정에서 전송 계층이 요구하는 서비스 품질(QoS)을 제공하기 위한 기능적, 절차적 수단으로 제공된다. 또한, 라우팅, 흐름 제어, 세그멘테이션, 오류제어, 인터네트워킹을 수행하기 때문에, 이 계층에서 동작하는 스위치가 있다. 정리하자면, 주소부여(IP), 경로설정(Route)를 해준다. 
    4. 전송(Transport) 계층 → 통신을 활성하기 위한 계층, TCP을 주로 이용하며 포트를 열어서 응용 프로그램들이 전송을 할 수 있게 해준다. 데이터가 4계층에 도착했으면, 해당 데이터를 하나로 합쳐서 5계층로 전송한다. 
    5. 세션(Session) 계층 → 데이터가 통신을 하기위한 논리적인 연결 계층이다. 세션 설정, 유지, 종료, 전송 중단시 복구 등의 기능이 있으며, End to End의 응용프로세스가 통신을 관리하기 위한 방법을 제공해준다. 동시 송수신 방식(duplex), 반이중 방식(half-duplex), 전이중 방식(Full Duplex)의 통신과 함께, 체크 포인팅과 유휴, 종료, 다시 시작 과정 등을 수행하는 계층이다. 
    6. 표현(Presentation) 계층 → 데이터 표현이 상이한 응용 프로세스의 독립성을 제공하고, 암호화를 한다. 보통 MIME 인코딩이나 암호화등의 동작이 여기서 이루어진다. 즉, 표현 계층에서는 데이터가 Text, Img, GIF, Png..등 구분을 하는 곳이다. 
    7. 응용(Application) 계층 → 최종 목적지로 HTTP, FTP, SMTP, POP3, IMAP, Telnet 등과 같은 프로토콜이 있다. 통신 패킷들은 나열한 프로토콜에 의해, 모두 처리가 된다. 흔히 사용하는 브라우저, 메일은 사용자가 프로토콜을 쉽게 사용해주는 응용 프로그램이다. 모든 통신의 양 끝단은 HTTP와 같은 프로토콜이지 응용프로그램이 아니기 때문에, 또한 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다 즉, 네트워크 소프트웨어의 UI 부분 및 사용자의 I/O부분이라고 생각하면 된다. 


  - TCP/IP 4계층
    - OSI 7 계층은 **데이터 통신에 필요한 계층과 역할을 정의한 참조 모델**이고, TCP/IP 4 계층은 인터넷에서 사용하는 프로토콜로, 단순한된 모델이라고 생각하면된다. 네트워크 연결 계층(Network Access Layer), 인터넷 계층(Internet Layer), 전송 계층(Transport Layer), 응용 계층(Application Layer)로 구성되어 있어 서로간의 간섭을 최소하고 유지와 보수에 있어 편리하다는 이점이 있다. 
    1. 네트워크 연결 계층(Network Access Layer) → 물리적인 데이터의 전송을 담당하는 계층으로 인터넷 계층과 달리 같은 네트워크 안에서 데이터가 전송된다. 노드 간의 신뢰성 있는 데이터 전송을 담당하며, 논리적인 주소가 아닌 물리적인 주소인 MAC을 참조해 장비간 전송을 하고, 기본적인 에러 검출과 패킷의 Frame를 담당한다.
    2. 인터넷 계층(Internet Layer) → 네트워크 상에서 데이터의 전송을 담당하는 계층으로 서로 다른 네트워크 간의 통신을 가능하게 하는 역할을 하기에 연결성을 제공해준다. 단말을 구분하기 위해 논리적인 주소로 IP 주소를 할당하게 되고 이 IP 주소로 네트워크 상의 컴퓨터를 식별하여 주소를 지정할 수 있도록 해준다. 네트워크끼리 연결하고 데이터를 전송하는 기기인 **라우터** 라고 하며, 라우터에 의한 네트워크 간의 전송을 **라우팅**'이라고 한다. 라우터가 내부의 라우팅 테이블을 통해 경로 정보를 등록하여 데이터 전송을 위한 최적의 경로를 찾고, 이렇게 출발지와 목적지 간의 데이터 전송 과정을 가리켜 End-to-End 통신이라고 부른다.
    3. 인터넷 계층(Internet Layer) → 통신 노드 간의 데이터 전송 및 흐름에 있어 신뢰성을 보장한다. 데이터를 적절한 어플리케이션에 제대로 전달되도록 배분하기에 End-to-End의 신뢰성을 확보한다. 전송 계층에 사용되는 대표적인 프로토콜로는 TCP와 UDP가 있다. TCP는 연결 지향형 프로토콜로 패킷에 하나의 오류라도 있으면 재전송을 위해 에러를 복구하는 반면, UDP는 패킷을 중간에 잃거나 오류가 발생해도 이에 대처하지 않고 계속해서 데이터를 전송하는 TCP에 비해 간단한 구조를 가지는 프로토콜이란 차이가 있다.
    4. 응용 계층(Application Layer) → 사용자와 가장 가까운 계층으로 사용자-소프트웨어 간 소통을 담당하는 계층이다. 웹 프로그래밍에서 보게되는 여러 서버나 클라이언트 관련 응용 프로그램들이 동작하는 계층이다. 주로 응용 프로그램들끼리 데이터를 교환하기 위한 계층이다. 
    
  - TCP/IP (Transmission Control Protocol & Internet Protocol)
    + **전송을 제어하는 프로토콜**로 전송 계층에서 사용하는 프로토콜, 장치들 사이에 논리적인 접속을 성립하기 위해 연결을 설정하여 **신뢰성**을 보장하는 연결형 서비스로, 네트워크에 연결된 컴퓨터 간에 데이터를 안정적이고, 순차적이며, 오류없이 교환을 한다.
    + 특징
      - **연결형 서비스**
        + 가상회선 방식을 제공하며, 3-way handshaking을 통해 연결을 설정하고 4-way handshaking을 통해 연결을 해제한다.
      - **흐름 제어(Flow Control)**
        + 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지한다.
        + 송신하는 곳에서 감당 안되게 많은 데이터를 빠르게 보내 수신하는 곳에서 문제가 발생하는 것을 막고
        + 수신자가 Window Size 값을 통해 수신량을 정할 수 있다.
      - **혼잡 제어(Congestion Control)**
        + 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하며, 정보량이 과다하면 패킷을 줄여 혼잡 붕괴 현상이 일어나는 것을 막아준다.
      - **신뢰성이 높은 전송(Reliable Transmission)**
        + Dupack-based retranmission → 정상적인 상황에서는 ACK(Acknowledgement) 값이 연속적으로 전송되어야 하고, ACK 값이 중복으로 올 경우 패킷 이상을 감지하고 재전송을 요청한다.
        + Timeout-based retransmission → 일정시간동안 ACK 값이 수신을 못할 경우 재전송을 요청한다.
      - **전이중/점대점 방식**
        + 전이중(Full Duplex) → 전송이 양방향으로 동시에 일어날 수 있다.
        + 점대점(Point to Point) → 각 연결이 정확히 2개의 종단점을 가지고 있다.
        + 멀티캐스팅이나 브로드 캐스팅을 지원하지 않는다. 
  

  - UDP (User Datagram Protocol)
    + **사용자 데이터그램 프로토콜**, 데이터그램은 독립적인 관계를 지니는 패킷을 뜻함.
    + UDP는 TCP와 달리, 비연결형 프로토콜이라, 할당되는 논리적인 경로가 없어 각각의 패킷은 다른 경로로 전송되고, 독립적인 관계를 지내게 되는데 이를 서로 다른 경로로 독립적으로 처리한다.
    + 특징
      - 비연결형 서비스로 데이트그램 방식을 제공
      - 데이터를 교환할 때 신호절차를 거치지 않음
      - UDP Header의 CheckSum 필드를 통해 최소한의 오류만 검출한다.
      - 신뢰성이 낮지만 TCP보단 전송 속도가 빠르다.
      - 주로 스트리밍 서비스 같은 연속성이 중요한 서비스에 사용함. 

즉, 신뢰성이 요구되는 애플리케이션은 TCP, 간단한 데이터를 빠른 속도로 전송할 때는 UDP를 사용한다. 

  - Dedicated Server
    + 서버 따로, 클라리언트 따로 즉, Server-Client 구조로 서버만 하는 것이 따로 있고, 클라이언트는 클라이언트의 역할만 한다.
    + 게임이 네트워크 멀티플레이어 세션을 호스팅하는 서버로 실행되며, 원격 클라이언트의 접속을 허용하지만, 로컬 플레이어는 없다.
    + 따라서, 더 효율적인 운영을 위해 그래픽, 사운드, 입력 및 기타 플레이어 중심 기능을 버린다. 주로 높은 지속성이나 보안, 대규모 멀티플레이어가 필요한 게임에 자주 사용된다.
    + 참고로, 비용이 비싸고 환경 설정이 어렵고 모든 플레이어가 별도의 컴퓨터에서 자체적으로 네트워크에 접속해야 한다. 

  - Listen Server
    + 한대의 컴퓨터가 호스트로, 서버역할 + 클라이언트 역할을 동시에 하는 것이다.
    + 게임이 네트워크 멀티플레이어 세션을 호스팅하는 서버로 실행되고, 원격 클라이언트의 접속을 허용한다.
    + 서버에 바로 로컬 플레이어가 있으며, 주로 가벼운 협동 및 경쟁 멀티플레이어에 자주 사용한다.
    + 다만, 서버로 실행하면서, 그래픽과 사운드 같은 플레이어 관련 시스템을 지원해야 하기 때문에, 추가 부하가 발생한다. 
  
  - P2P
    + 간단하게 이야기 하자면, 각각의 컴퓨터가 서버이면서 동시에 클라이언트까지 동작하는 방식이다. 

[언리얼 네트워킹 개요](https://dev.epicgames.com/documentation/ko-kr/unreal-engine/networking-overview-for-unreal-engine)

<img src="https://github.com/VidanSilk/CS-Study/blob/main/CS_KeyWord/_img/Ue5NetWorkImg.png"  width="400" height="500"></img>

일단, 리플리케이션 개념은 **서버/클라 통신**과 관련된 개념이다. 모든 데이터를 서버에 둘 수도 없고, 모든 데이터를 클라에만 둘 수도 없으며, 클라이언트에 필요는 하지만 서버에서만 관리해야하는 데이터가 있을수도 있고 등등 여러 문제가 존재하는데 이를 정리한 것이 리플리케이션이다. <br>
언리얼 네트워크 시스템상에서 각 요소(Actor) 들은 크게 3가지로 나뉜다. Server Only, Server/Client Multy, ClientOnly <br>
Server Only는 게임 관리자에 해당하는 **GameMode**가 포함되며 Server/Client Multy는 게임 상태을 담당하는 **GameState** (점수, 스탯, 이동정보 등등) 하지만 중요한건 Server/Client Side **양측에 모두 존재하는 액터들**이다. <br>
물론 여기서도 몇가지가 나뉘어 지는데, 

1. 서버가 무조건 우선권을 가지는 경우 → 관리 권한이 존재 
2. 모든 클라이언트가 소유하고 있어야 하는 경우 → 관리 권한은 없으나 소유권은 있음
3. 지금 화면을 보고 있는 클라이언트의 정보만 있어야 하는 경우 → 관리 권한도 없고, 소유권도 없음

이런식으로 3가지 타입으로 구별이 가능하고 이를, **Authority, Autonomous, Simulated**라고 표현한다. 

[액터 롤 및 리모트 롤 4.27](https://dev.epicgames.com/documentation/ko-kr/unreal-engine/actor-role-and-remoterole?application_version=4.27)
    
  + 정리
  + 언리얼 서버는 **복제(Replicate)** 로 서버에 내용을 클라이언트들에게 복제해주는데, 개발 할 때 클라이언트가 정해야하는 것은 어떤 것은 복제를 하고, 어떤 것은 복제를 안 해야하는지를 정하는거다
  + 리플레케이트 방식에는 변수와 함수가 있다.
    - 변수 → 리플리케이트, 렙노티파이 리플리케이트 서버에서 값이 변경되면 바로 클라이언트로 동기화 된다. 렙 노티파이 서버에서 값이 변경되면 값이 변경을 호출하고 일어날 때 바인드된 OnRep 함수를 호출한다.
    - 함수 → RPC(Remote Procedure Call)라 부르고, 방식에는 Server, Client, Multicast 3가지가 있다. 중요한 건, Server를 제외한 다른 2가지 (Client, Multicast) 서버에서만 동작이 정상적으로 된다. 클라이언트 서버로 호출할 때 Server를 사용한다.

함수를 구현할 때 서버랑 클라이언트를 구분하는 방법은 다음과 같다. <br>
Authority : 서버 <br>
Remote : 클라이언트 
      
6.
