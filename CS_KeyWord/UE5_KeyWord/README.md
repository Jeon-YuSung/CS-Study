# 언리얼 엔진 5 이론 및 키워드 정리 언리얼 엔진 5 이론 및 키워드 정리

언리얼 엔진 키워드를 정리하는 곳입니다 

[Unreal Engine5 Docs](https://dev.epicgames.com/documentation/ko-kr/unreal-engine/unreal-engine-5-7-documentation)

--------------------------------------------------------------------------------

1. 좌표계
  - 유니티, DX, UE5등 왼손 좌표계 사용, 다만 언리얼 엔진은 **Z축이 위** <br>
  -  x축 Roll, y축 Pitch, z축 Yaw

UE5 좌표계 및 다양한 그래픽스 좌표계

<img src="https://github.com/VidanSilk/CS-Study/blob/main/CS_KeyWord/_img/3DCoordinateSystems.png"></img>

2. BluePrint / C++
  - **BluePrint**
      + 블루프린트는 에디터에서 노드 기반 인터페이스를 통해 게임 플레이 요소를 만들어주는 개념
      + 스크립팅 - 행동을 보다 손쉽게 정의 가능  
      + 빠른 반복 작업- 블루프린트 클래스를 더 빠르게 생성, 수정, 컴파일 및 테스트가 가능해서 프로토타이핑에 적합
      + 폭 넓은 접근성 - DataFlow가 시가적으로 표현되어, 쉽게 이해 가능하고, 진입 장벽이 낮음.
      + 향상된 검색 기능 - 쉽게 API, 에셋 레퍼런스를 검색하고 포함 가능
      + 안전한 메모리 모델 - 크래시를 방지할 수 있는 안전한 메모리 모델을 갖춤 
      + 단점 : 추가 기능이나 새로운걸 만들 때는, 기능을 제공 하지 않은 경우가 있음. 

      + [BluePrint Docs](https://dev.epicgames.com/documentation/ko-kr/unreal-engine/introduction-to-blueprints-visual-scripting-in-unreal-engine)
  
  - **C++**
      + 빠른 런타임 - 블루프린트 로직보다 훨씬 빠름, 쉽게 빌드 가능 
      + 명확한 디자인이 가능 - C++에서 변수나 함수를 노출하면, 세밀한 제어를 통해 원하는걸 정확히 노출할 수 있고, 특정 함수/변수를 보호하고 클래스의 공식 API를 만들 수 있음. 즉, 지나치게 크고 따라잡기 어려운 블루프린트를 만들지 않아도 됨.
      + 광범위한 엑세스 - UE의 로우 레벨 함수 기능에 접근 가능 
      + 폭넓은 확장성 - 외부 시스템 및 라이브러리를 생성하고 인터페이싱 가능, 대규모 블루프린트 그래프와 비교하여 보다 쉽게 수정할 수 있음 
      + 강력한 제어 - 시스템, 리소스 및 복잡한 알고리즘에 대한 로우 레벨 제어 가능 
      + 원활한 협업 - 텍스트로 저장되기 때문에, 프로젝트 간의 비교, 병합 및 공유가 쉬움 
      + 뛰어난 디버깅 - 블루프린트 디버거 보다 더 강력한 디버깅 툴이 존재 

C++ 클래스를 블루프린트로 확장시켜 새로운 게임플레이 클래스를 코드로 구성하면, 레벨 디자이너는 이것을 기반으로 블루프린트를 통해 작업 및 변경이 가능함. <br>
C++ 클래스와 블루프린트 시스템간의 상화작용에 영향을 끼치는 지정자가 여러가지가 있음. 

3. UObject
  - C++로 class를 작성하면 UClass가 붙는데, UHT(Unreal Header Tool) 코드를 분석 <br>
  - 엔진 실행시, 분석한걸 토대로 리플랙션 데이터를 통해 CDO(Class Default Object)를 UObject로 인스턴스(객체)를 만들어주고 CDO복사해서 동적으로 사용하는 시스템.
  - 주기적으로 리플랙션에서 사용하지 않는 Object들은 GC(Garbage Collection)이 메모리 정리 해줌.
  
4. UHT / UBT
   
빌드를 시작하면 UBT가 실행되고, UBT은 C++ 컴파일러 실행전에 UHT를 실행하는데, UHT은 헤더 파일을 Parsing하고 UGameplayAbility_AutoAttack.generated.h,UGameplayAbility_AutoAttack.gen.cpp에 UPROPERTY, UFUNCTION, UCLASS매크로 선언된 정보들을 저장하는 역할을 수행 <br>
이 과정이 끝나면 UHT의 작업은 끝나게 되고, 일반 C++컴파일러가 UHT이 생성한 코드를 포함해서 C++컴파일을 수행 

   - **UHT(Unreal Header Tool)**
     + C++ 코들을 컴파일 하기전에 모든 헤더파일들을 순회하면서, 언리얼 리플렉션 시스템에 필요한 정보을 읽어들 후, .generate.h 파일과 gen.cpp파일을 Intermediate폴더에 생성하는 소프트웨어
     + 자체적으로 리플렉션 시스템을 구현하기 위해 UCLASS(),UPROPERTY(),UFUNCTION() 등의 매크로를 사용하고, 이 매크로를 해석해서 C++ 컴파일러가 알아들을 수 있게 코드를 생성(.generate.h, .gen.cpp)해주는 작업. 
       
   - **UBT(Unreal Build Tool)**
     + Uproject, Target.cs, Build.cs를 읽어서 어떻게 빌드할지 정함
     + UBT가 UHT를 실행해서 모든 헤더파일을 읽어서 언리얼 매크로들(UClass, UFuntion 등....)을 전부 다 찾아서, 이 정보를 바탕으로 리플랙션 시스템을 사용할 수 있게 컴파일러가 인식할 수 있게 .generated.h 파일을 생성
     + UBT가 C++ 컴파일러를 호출해서 캄파일 및 UHT가 만든 .generated.h 코드를 합쳐 컴파일하고, 이 결과물이 Binaries폴더에 exe랑 dll로 나옴.
     + 바이너리가 실행되면 엔진 또는 게임이 메모리에 올라가서, 모든 생성된 언리얼 오브젝트들 클래스 별로 각 기본 CDO가 메모리에 등록된다.
     + 참고로 **.generated.h는 항상 가장 마지막 밑에 include**해야한다. 아니면 인식이 제대로 안되어, 에러가 발생한다.

5. Uneral Server

일단 클라이언트 프로그래머가 언리얼 네티워크를 안다고 서버 프로그래머가 되는 것이 아니다. 클라 입장에서 서버를 공부하는 것으로, 클라가 하는 일들 중에서 '서버로 ~ 값이 변경 되었다고' 알려주는 것이다. 언리얼 네트워크는 일단 TCP로 구현 되어있다. <br>
다만, 일반적인 TCP 방식이 아닌 Replicate라는 시스템을 도입하였다.
  
  - OSI 7계층
    1. 물리(Physical) 계층
    2. 데이터 링크 계층
    3. 네트워크 계층 
    4. 전송 계층 
    5. 세션 계층
    6. 표현 계층
    7. 응용 계층
    - 나중에 추가로 정리. 

  -TCP/IP 4계층
    -추가정리 
    
  - TCP/IP (Transmission Control Protocol & Internet Protocol)
    + **전송을 제어하는 프로토콜**로 전송 계층에서 사용하는 프로토콜, 장치들 사이에 논리적인 접속을 성립하기 위해 연결을 설정하여 **신뢰성**을 보장하는 연결형 서비스로, 네트워크에 연결된 컴퓨터 간에 데이터를 안정적이고, 순차적이며, 오류없이 교환을 한다.
    + 특징
      - **연결형 서비스**
        + 가상회선 방식을 제공하며, 3-way handshaking을 통해 연결을 설정하고 4-way handshaking을 통해 연결을 해제한다.
      - **흐름 제어(Flow Control)**
        + 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지한다.
        + 송신하는 곳에서 감당 안되게 많은 데이터를 빠르게 보내 수신하는 곳에서 문제가 발생하는 것을 막고
        + 수신자가 Window Size 값을 통해 수신량을 정할 수 있다.
      - **혼잡 제어(Congestion Control)**
        + 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하며, 정보량이 과다하면 패킷을 줄여 혼잡 붕괴 현상이 일어나는 것을 막아준다.
      - **신뢰성이 높은 전송(Reliable Transmission)**
        + Dupack-based retranmission → 정상적인 상황에서는 ACK(Acknowledgement) 값이 연속적으로 전송되어야 하고, ACK 값이 중복으로 올 경우 패킷 이상을 감지하고 재전송을 요청한다.
        + Timeout-based retransmission → 일정시간동안 ACK 값이 수신을 못할 경우 재전송을 요청한다.
      - **전이중/점대점 방식**
        + 전이중(Full Duplex) → 전송이 양방향으로 동시에 일어날 수 있다.
        + 점대점(Point to Point) → 각 연결이 정확히 2개의 종단점을 가지고 있다.
        + 멀티캐스팅이나 브로드 캐스팅을 지원하지 않는다. 
  

  - UDP (User Datagram Protocol)
    + **사용자 데이터그램 프로토콜**, 데이터그램은 독립적인 관계를 지니는 패킷을 뜻함.
    + UDP는 TCP와 달리, 비연결형 프로토콜이라, 할당되는 논리적인 경로가 없어 각각의 패킷은 다른 경로로 전송되고, 독립적인 관계를 지내게 되는데 이를 서로 다른 경로로 독립적으로 처리한다.
    + 특징
      - 비연결형 서비스로 데이트그램 방식을 제공
      - 데이터를 교환할 때 신호절차를 거치지 않음
      - UDP Header의 CheckSum 필드를 통해 최소한의 오류만 검출한다.
      - 신뢰성이 낮지만 TCP보단 전송 속도가 빠르다.
      - 주로 스트리밍 서비스 같은 연속성이 중요한 서비스에 사용함. 

즉, 신뢰성이 요구되는 애플리케이션은 TCP, 간단한 데이터를 빠른 속도로 전송할 때는 UDP를 사용한다. 

  - Dedicated Server
    + 서버 따로, 클라리언트 따로 즉, Server-Client 구조로 서버만 하는 것이 따로 있고, 클라이언트는 클라이언트의 역할만 한다. 
    + 추가 정리
  
  - Listen Server
    + 한대의 컴퓨터가 호스트로, 서버역할 + 클라이언트 역할을 동시에 하는 것이다.
    + 추가정리 할것
  
  - P2P
    + 간단하게 이야기 하자면, 각각의 컴퓨터가 서버이면서 동시에 클라이언트까지 동작하는 방식이다. 
    
  + 정리
  + 언리얼 서버는 **복제(Replicate)** 로 서버에 내용을 클라이언트들에게 복제해주는데, 개발 할 때 클라이언트가 정해야하는 것은 어떤 것은 복제를 하고, 어떤 것은 복제를 안 해야하는지를 정하는거다
  + 리플레케이트 방식에는 변수와 함수가 있다.
    - 변수 → 리플리케이트, 렙노티파이 리플리케이트 서버에서 값이 변경되면 바로 클라이언트로 동기화 된다. 렙 노티파이 서버에서 값이 변경되면 값이 변경을 호출하고 일어날 때 바인드된 OnRep 함수를 호출한다.
    - 함수 → RPC(Remote Procedure Call)라 부르고, 방식에는 Server, Client, Multicast 3가지가 있다. 중요한 건, Server를 제외한 다른 2가지 (Client, Multicast) 서버에서만 동작이 정상적으로 된다. 클라이언트 서버로 호출할 때 Server를 사용한다.


함수를 구현할 때 서버랑 클라이언트를 구분하는 방법은 다음과 같다. <br>
Authority : 서버 <br>
Remote : 클라
      


6.
