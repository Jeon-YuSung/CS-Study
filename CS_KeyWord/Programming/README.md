# 프로그래밍 + 자료구조 용어 정리

객체 지향에서 자주 쓰이는 용어 (혹은 CPP에서 자주 쓰는 용어)

-------------------------------------------------------------
## 1. 프로그래밍 (CPP)

1. 객체지향 프로그래밍(OPP)이란?
   - 프로그래밍 패러다임 중 하나로, 프로그래밍에서 필요한 데이터를 추상화시켜 상태(state - 데이터, 속성)와 행위(Behavior - 메서드, 함)를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.
   - **장점**
     + 코드 재사용이 용이 : 남이 만든 클래스를 가져와서 이용하거나 상속을 통해 확장이 가능
     + 유지보수가 쉬움 : 절차지향 프로그래밍은 코드를 수정할 때 일일이 찾아 수정해야하지만, 객체 지향 프로그래밍에서 수정해야할 부분이 클래스 내부의 멤버 변수 혹은 메서드(함수)로 존재하기 대문에 해당 부분만 수정하면 된다.
     + 대형 프로젝트에 적합 : 클래스 단위로 모듈화 시켜 개발할 수 있어서 업무 분담하기에 쉽다.
  
   - **단점**
     + 처리속도가 상대적으로 느리다.
     + 객체가 많으면 용량이 커질 수 있다.
     + 설계시 많은 시간과 노력이 필요하다.

그럼 클래스와 인스턴스(객체)는 무엇일까? <br>
  - **클래스**
    + 어떤 문제를 해결하기 위한 데이터를 만들기 위해 추상화를 거쳐 집단에 속하는 속성(Attribute)와 행위(Behavior)를 변수와 메서드로 정의한 것으로 객체를 만들기 위한 메타정보라고 볼 수 있다. 또한 클래스와 구조체의 차이는 1-7 질문을 참고하자.
  
  - **인스턴스(객체)**
    + 클래스를 정의한 것을 토대로 실제 메모리에 할당된 것. 즉, 실제 프로그램에서 사용할 데이터 

추가적으로 **절차지향 프로그래밍**이란? 
  - 절차는 함수를 의미하고, 절차적 프로그램밍이란 반복되는 동작을 함수 및 프로시저 형태로 모듈화하여 사용하는 방식이다.
  - 순차적인 처리를 중요하게 여기고, 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법으로 장점은 컴퓨터의 처리 구조와 유사해서 실행속도가 빠르고, 각 프로그램의 흐름을 쉽게 추적할 수 있다. 하지만, 각 코드의 유기성이 매우 높아 유지보수가 어렵고, 실행순서가 정해져 있어, 코드의 순서가 바뀌면 동일한 결과가 보장되지 않는다. 

2. 객체지향의 4대 특징은?
   - A. 캡슐화(Encapsultaition) - 데이터와 메서드를 하나의 단위로 묶어, 외부에서 접근하지 못하도록 보호하는 개념으로, 캡슐화를 통해 데이터를 보호 및 은닉할 수 있다.
     + 보호란? 외부로부터 클래스에 정의된 속성과 기능들을 보호하는 것
     + 은닉이란? 내부의 동작을 감추고, 외부에는 필요한 부분만 공개하는 것.
   - B. 상속(Inheritance) - 여러 객체들이 지닌 공통된 특성을 하나의 개념이나 법칙으로 성립하는 과정으로 이를 통해 재사용 및 코드의 중복을 제거한다. 상속을 통해 서브 클래스는 기본 클래스의 변수와 기능을 물려받는다. 
   - C. 추상화(Abstration) - **공통의 속성이나 기능**을 묶어 이름을 붙이는 것, 즉, 객체들의 공통적인 속성과 기능을 추출하여 정의하는 것이다. 
   - D. 다형성(Polymorphism) - 같은 자료형에 여러 가지 타입의 데이터를 대입하여 다양한 결과를 얻어낼 수 있는 성질로, 대표적인 개념으로 오버로딩과 오버라이딩이 있다.
     + **오버로딩(OverLoading)** - 함수 중복 정의, 즉 같은 이름의 함수를 매개변수만 다르게 사용해서, 매개변수에 따라 다른 함수가 실행된다. 함수 이름이 같아야하고, 리턴형은 달라도 되지만, 매개변수의 개수가 달라져야한다. 만약 같을 경우 자료형이 달라져야한다. 
     + **오버라이딩(Overriding)**  - 함수 재정의, 서브 클래스에서 기본 클래스의 메서드를 재정의해서 사용하는 것으로, 기본 클래스의 메서드를 재사용하기에 독자적인 기능을 추가할 수 있다. override하고자 하는 함수가 기본 클래스에 있어야 하며, 이름이 같아야 한다. 또한 함수의 매개변수, 자료형 및 리턴이 같아야하고, 기본 함수와 동일하거나 내용이 추가되어야한다. 

3. 객체지향의 솔리드 원칙은?
  - A. 단일 책임 원칙 (Single Responsibility Principle), (SRP) : 한 클래스는 **하나의 단일 책임**만 가져야 한다. 
  - B. 개방-폐쇄 원칙 (Open-closed Principle), (OCP) : 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다. 즉, **기존의 코드를 변경하지 않고 기능을 수정하거나 추가**할 수 있도록 해야한다. 
  - C. 리스코프 치환 원칙 (Liskov Substitution Principle), (LSP) : 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다. **계약에 의한 설계를 참고**하라. 즉, 하위 타입 객체는 상위 타입 객체에서 가능한 행위를 수행할 수 있어야함 -> 상위 타입 객체를 하위 타입객체로 치환해도 정상적으로 동작해야함. 상속 관계에서는 **일반화 관계 IS-A가 성립**해야 함.
  - D. 인터페이스 분리 원칙 (Interface Segregation Principle), (ISP) : 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다. 즉, 자신이 사용하는 메소드에만 의존해야하며, 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 않아야함 → 하나의 통상적인 인터페이스보다는 **여러 개의 세부적이고 구체적인 인터페이스**가 낫다.
  - E. 의존관계 역전 원칙 (Dependency Inversion Principle), (DIP) : 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다. 의존성 주입은 이 원칙을 따르는 방법 중 하나다. 즉, 의존 관계를 맺을 때, 변하기 쉬운 구체적인 것 보다는 **변하기 어려운 추상적인 것에 의존** 해야 한다.
    
4. 인라인 함수란?
   - 라인 안에서 실행되는 함수이다. 즉, 함수 호출(call)를 하지 않아도 함수 정의(Definition)자체를 그대로 스크립트에 복사해서 실행한다. **속도가 빠르다는 장점**이 있다. 하지만 inline을 남용하면 실행코드가 늘어나, 컴파일 시간이 길어지고, 실행 파일의 크기가 커진다는 단점이 있다. 보통 클래스안에 함수를 선언하고 정의하면 컴파일러가 암시적으로 인라인 함수로 처리한다. 혹은 명시적으로 함수명 앞에 inline 키워드를 붙여도 된다. 

5. std::의 뜻, 그리고 using namespace std;을 지양해야하는 이유는?
   - std는 standard의 약자로 C++표준 라이브러리에 정의된 모든 함수, 클래스, 변수 etc.. std라는 네임스페이스 안에 있다. std::cout, std::vector, std::string... 등등
   - ::는 범위 지정 연산자로 특정 네임스페이스에 속한 요소를 지정해주는 역할을 한다.
   - using namespace std;란 std::를 입력하지 않은 경우 알아서 std::를 넣어서 판단하라고 컴파일러에 전달하는 것으로, std라는 이름을 붙이지 않고도 cout, endl를 사용 가능하다. 하지만, 어떠한 이름 공간을 사용하겠다는 선언하는 것은 권장되지 않는데, std에 이름이 겹치는 함수를 만들게 된다면, 오류가 발생하고 C++ 표준 라이브러리는 매우 커서, 수 많은 함수들이 존재하기 때문에 이름을 겹쳐서 사용하게되면 나중에 유지보수하는 데 시간을 많이 투자할 수 있다. 또한, std에는 매번 수많은 함수들이 새롭게 추가되고 있기 때문에, C++버전 마다 이름 충돌로 인해 동작하지 않은 문제가 발생 할 수 있다. 그렇기 때문에, std::를 직접 앞에 붙여서 std의 이름공간의 함수이다 명시하는 것이 좋다. 즉, **혹시 모를 이름 충돌로부터 보호하는 것**이 중요하다.
    
6. map과 unordered_map의 차이는?
7. 사용자 정의 타입이란 무엇인가?
8. 클래스(class)와 구조체(struct)의 차이는?
9. enum과 enum class의 차이는?
10. Union은 무엇인가?
11. 포인터의 개념은?
12. 스마트 포인터에 대해 설명하고, unique_ptr과 shared_ptr의 차이점은?
13. std::function은 무엇인가?
14. Array와 Vector 그리고 List의 차이는?

---------------------------------------------------------------------
## 2. 자료구조 
  - 2-1. 자료구조 개념
  - 2-2. 선형 구조와 비선형구조의 특징
  - 
