# 프로그래밍 + 자료구조 용어 정리

객체 지향에서 자주 쓰이는 용어 (혹은 CPP에서 자주 쓰는 용어)

-------------------------------------------------------------
## 1. 프로그래밍 (CPP)

1. 객체지향 프로그래밍(OPP)이란?
   - 프로그래밍 패러다임 중 하나로, 프로그래밍에서 필요한 데이터를 추상화시켜 상태(state - 데이터, 속성)와 행위(Behavior - 메서드, 함수)를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.
   - **장점**
     + 코드 재사용이 용이 : 남이 만든 클래스를 가져와서 이용하거나 상속을 통해 확장이 가능
     + 유지보수가 쉬움 : 절차지향 프로그래밍은 코드를 수정할 때 일일이 찾아 수정해야하지만, 객체 지향 프로그래밍에서 수정해야할 부분이 클래스 내부의 멤버 변수 혹은 메서드(함수)로 존재하기 대문에 해당 부분만 수정하면 된다.
     + 대형 프로젝트에 적합 : 클래스 단위로 모듈화 시켜 개발할 수 있어서 업무 분담하기에 쉽다.
  
   - **단점**
     + 처리속도가 상대적으로 느리다.
     + 객체가 많으면 용량이 커질 수 있다.
     + 설계시 많은 시간과 노력이 필요하다.

그럼 클래스와 인스턴스(객체)는 무엇일까? <br>
  - **클래스**
    + 어떤 문제를 해결하기 위한 데이터를 만들기 위해 추상화를 거쳐 집단에 속하는 속성(Attribute)와 행위(Behavior)를 변수와 메서드로 정의한 것으로 객체를 만들기 위한 메타정보라고 볼 수 있다. 또한 클래스와 구조체의 차이는 1-7 질문을 참고하자.
  
  - **인스턴스(객체)**
    + 클래스를 정의한 것을 토대로 실제 메모리에 할당된 것. 즉, 실제 프로그램에서 사용할 데이터 

추가적으로 **절차지향 프로그래밍**이란? 
  - 절차는 함수를 의미하고, 절차적 프로그램밍이란 반복되는 동작을 함수 및 프로시저 형태로 모듈화하여 사용하는 방식이다.
  - 순차적인 처리를 중요하게 여기고, 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법으로 장점은 컴퓨터의 처리 구조와 유사해서 실행속도가 빠르고, 각 프로그램의 흐름을 쉽게 추적할 수 있다. 하지만, 각 코드의 유기성이 매우 높아 유지보수가 어렵고, 실행순서가 정해져 있어, 코드의 순서가 바뀌면 동일한 결과가 보장되지 않는다. 

2. 객체지향의 4대 특징은?
   - A. 캡슐화(Encapsultaition) - 데이터와 메서드를 하나의 단위로 묶어, 외부에서 접근하지 못하도록 보호하는 개념으로, 캡슐화를 통해 데이터를 보호 및 은닉할 수 있다.
     + 보호란? 외부로부터 클래스에 정의된 속성과 기능들을 보호하는 것
     + 은닉이란? 내부의 동작을 감추고, 외부에는 필요한 부분만 공개하는 것.
   - B. 상속(Inheritance) - 여러 객체들이 지닌 공통된 특성을 하나의 개념이나 법칙으로 성립하는 과정으로 이를 통해 재사용 및 코드의 중복을 제거한다. 상속을 통해 서브 클래스는 기본 클래스의 변수와 기능을 물려받는다. 
   - C. 추상화(Abstration) - **공통의 속성이나 기능**을 묶어 이름을 붙이는 것, 즉, 객체들의 공통적인 속성과 기능을 추출하여 정의하는 것이다. 
   - D. 다형성(Polymorphism) - 같은 자료형에 여러 가지 타입의 데이터를 대입하여 다양한 결과를 얻어낼 수 있는 성질로, 대표적인 개념으로 오버로딩과 오버라이딩이 있다.
     + **오버로딩(OverLoading)** - 함수 중복 정의, 즉 같은 이름의 함수를 매개변수만 다르게 사용해서, 매개변수에 따라 다른 함수가 실행된다. 함수 이름이 같아야하고, 리턴형은 달라도 되지만, 매개변수의 개수가 달라져야한다. 만약 같을 경우 자료형이 달라져야한다. 
     + **오버라이딩(Overriding)**  - 함수 재정의, 서브 클래스에서 기본 클래스의 메서드를 재정의해서 사용하는 것으로, 기본 클래스의 메서드를 재사용하기에 독자적인 기능을 추가할 수 있다. override하고자 하는 함수가 기본 클래스에 있어야 하며, 이름이 같아야 한다. 또한 함수의 매개변수, 자료형 및 리턴이 같아야하고, 기본 함수와 동일하거나 내용이 추가되어야한다. 

3. 객체지향의 솔리드(SOLID)원칙은?
  - A. 단일 책임 원칙 (Single Responsibility Principle), (SRP) : 한 클래스는 **하나의 단일 책임**만 가져야 한다. 
  - B. 개방-폐쇄 원칙 (Open-closed Principle), (OCP) : 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다. 즉, **기존의 코드를 변경하지 않고 기능을 수정하거나 추가**할 수 있도록 해야한다. 
  - C. 리스코프 치환 원칙 (Liskov Substitution Principle), (LSP) : 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다. **계약에 의한 설계를 참고**하라. 즉, 하위 타입 객체는 상위 타입 객체에서 가능한 행위를 수행할 수 있어야함 -> 상위 타입 객체를 하위 타입객체로 치환해도 정상적으로 동작해야함. 상속 관계에서는 **일반화 관계 IS-A가 성립**해야 함.
  - D. 인터페이스 분리 원칙 (Interface Segregation Principle), (ISP) : 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다. 즉, 자신이 사용하는 메소드에만 의존해야하며, 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 않아야함 → 하나의 통상적인 인터페이스보다는 **여러 개의 세부적이고 구체적인 인터페이스**가 낫다.
  - E. 의존관계 역전 원칙 (Dependency Inversion Principle), (DIP) : 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다. 의존성 주입은 이 원칙을 따르는 방법 중 하나다. 즉, 의존 관계를 맺을 때, 변하기 쉬운 구체적인 것 보다는 **변하기 어려운 추상적인 것에 의존** 해야 한다.
    
4. 인라인 함수란?
   - 라인 안에서 실행되는 함수이다. 즉, 함수 호출(call)를 하지 않아도 함수 정의(Definition)자체를 그대로 스크립트에 복사해서 실행한다. **속도가 빠르다는 장점**이 있다. 하지만 inline을 남용하면 실행코드가 늘어나, 컴파일 시간이 길어지고, 실행 파일의 크기가 커진다는 단점이 있다. 보통 클래스안에 함수를 선언하고 정의하면 컴파일러가 암시적으로 인라인 함수로 처리한다. 혹은 명시적으로 함수명 앞에 inline 키워드를 붙여도 된다. 

5. std::의 뜻, 그리고 using namespace std;을 지양해야하는 이유는?
   - std는 standard의 약자로 C++표준 라이브러리에 정의된 모든 함수, 클래스, 변수 etc.. std라는 네임스페이스 안에 있다. std::cout, std::vector, std::string... 등등
   - ::는 범위 지정 연산자로 특정 네임스페이스에 속한 요소를 지정해주는 역할을 한다.
   - using namespace std;란 std::를 입력하지 않은 경우 알아서 std::를 넣어서 판단하라고 컴파일러에 전달하는 것으로, std라는 이름을 붙이지 않고도 cout, endl를 사용 가능하다. 하지만, 어떠한 이름 공간을 사용하겠다는 선언하는 것은 권장되지 않는데, std에 이름이 겹치는 함수를 만들게 된다면, 오류가 발생하고 C++ 표준 라이브러리는 매우 커서, 수 많은 함수들이 존재하기 때문에 이름을 겹쳐서 사용하게되면 나중에 유지보수하는 데 시간을 많이 투자할 수 있다. 또한, std에는 매번 수많은 함수들이 새롭게 추가되고 있기 때문에, C++버전 마다 이름 충돌로 인해 동작하지 않은 문제가 발생 할 수 있다. 그렇기 때문에, std::를 직접 앞에 붙여서 std의 이름공간의 함수이다 명시하는 것이 좋다. 즉, **혹시 모를 이름 충돌로부터 보호하는 것**이 중요하다.
    
6. map과 unordered_map의 차이는?
   - **map**
     + 각 키가 고유한 key - value 쌍의 모음을 저장하는 데이터 구조로, 연관 배열, 사전 또는 해쉬 맵이라고한다. key을 이용해서 value에 접근을 하기 때문에, key은 고유한 값, 즉 중복될 수 없다. 만약 중복을 원한다면 multimap을 사용해야 한다. 또한 map의 구조는 트리형태로 구현되어 있고, 데이터 검색 속도를 빠르게 하기위해 key 값을 중심으로 오름차순 정렬로 저장을 한다. 만약 내림차순으로 정렬하고 싶다면 greater를 추가하면 된다.  key 값을 데이터 삽입/삭제 등을 하는 경우, 데이터를 항상 정렬해야하기 때문에 정렬을 위한 추가적인 시간이 필요하여 시간 복잡도는 O(log n), 또한 탐색 시간도 이진 탐색 트리 기반이기에 O(log n)이다.
   - **unordered_map**
     + 해쉬 테이블로 구현한 자료구조로 일반적인 map보다 삽입, 삭제, 원소 접근등이 빠르다. **해쉬 테이블** 구조이기 때문에, 정렬을 하지 않아 순서가 있게(오름차순, 내림차순) 데이터를 보관하고 있지 않는다. 주로 데이터가 많으면 사용하는 경우가 많지만, 데이터가 적을 때에는 메모리 낭비나 검색시 오버헤드가 발생할 수 있다. key 값이 유사한 데이터가 많을 경우 해쉬 테이블에 고르게 저장되지 않아 해쉬 충돌이 발생하여 성능이 떨어질 수도 있다. 시간 복잡도는 O(1)이다.

해쉬 테이블(Hash Table)이란 ? <br> 
   - 해시 맵, 해시표는 컴퓨텅에서 key를 value에 매핑할 수 있는 구주로, 연관 배열(연상 배열, 결합형 배열, map, dictionnary) 추가에 사용되는 자료 구조이다. 즉, 키를 사용하여 그 키에 해당하는 값을 찾기 위해 필요한, 빠른 속도로 키를 검색할 수 있는 자료구조를 의미한다. 해시 테이블은 해시 함수를 사용해서 색인(index)을 버킷(bucket)이나 슬롯(slot)의 배열로 계산한다. 

연관 배열(Associative Array) 이란 ? <br> 
   - 자료구조의 하나로, 키 하나와 값 하나가 연관되어 있으며 키를 통해 연관되는 값을 얻을 수 있다. 연상 배열, 결합형 배열, 맵(map), 사전(dictionary)이라고도 한다. 보통 다음과 같은 명령을 지닌다. <br>
      + 키와 값이 주어졌을 때, 연관 배열에 그 두 값을 저장하는 명령
      + 키가 주어졌을 때, 연관되는 값을 얻는 명령
      + 키와 새로운 값이 주어졌을 때, 원래 키에 연관된 값을 새로운 값으로 교체하는 명령
      + 키가 주어졌을 때, 그 키에 연관된 값을 제거하는 명령

해쉬 함수(Hash Function) 이란? <br>
   - 해시 알고리즘(Hash Algorithm) 또는 해시함수알고리즘이라고도 하는데, **임의의 길이의 데이터를 고정된 길이의 데이터로 매핑**하는 함수이다. 해시 함수에 의해 얻어지는 값은 해시 값, 해시 코드, 해시 체크섬 또는 간단하게 해시라고 한다. 매우 빠른 데이터 검색을 위해 사용하며, 해시 함수는 큰 파일에서 중복되는 레코드를 찾을 수 있기 때문에 데이터베이스 검색이나 테이블 검색의 속도를 높힐 수 있다. 암호학에서도 사용할 수 있는데, 암호용 해시 함수는 매핑된 해싱 값만을 알아가지고는 원래 입력 값을 알아내기 힘들다점을 이용하여 구현한다. 그뿐만이 아니라, 전송된 데이터의 무결성을 확인해주는 데 사용되기도 하는데, 메시지가 누구에게서 온 것인지 입증해주는 HMAC를 구성하는 블록으로 사용된다. 해시 함수는 결정론적으로 작동해야 하며, 따라서 **두 해시 값이 다르다면 그 해시값에 대한 원래 데이터도 달라야 한다**. (역성립 X) 해시 함수의 질은 입력 영역에서의 해시 충돌 확률로 결정되는데, 해시 **충돌의 확률이 높을수록 서로 다른 데이터를 구별하기 어려워지고 검색하는 비용이 증가**하게 된다.

8. 사용자 정의 타입(User Defined Type)이란 무엇인가? <br>
   - int, char, double, float etc...이러한 자료형들은 내장형 타입이라고 하고, 내장형 타입은 개발자가 그에 대한 선언을 소스 코드에 제공하지 않아도 컴파일러 스스로 해당 객체를 어떻게 표현하고, 그 객체에 적용 가능한 연산이 무엇인지 알고 있는 타입을 뜻한다. 반대로, 내장형 타입이 아닌 **모든 타입은 사용자 정의 타입(UDT, User-Defined Type)** 이라고 하고, 모든 ISO 표준 C++ 구현체에서 사용할 수 있는 string, vector, ostream... 등 비롯한 표준 라이브러리 혹은 직접 만드는 타입들이 사용자 정의 타입이라고 한다. 표준 라이브러리 타입은 내장형 타입 처럼 언어의 구성 요소라고도 할 수 있으나, 스스로 정의하는 타입과 동일한 구성 요소와 기법으로 만들어져서 여전히 사용자 정의 타입으로 볼 수 있다. 표준 라이브러리 개발자가 특별한 권한을 보유하거나 남들에게 제공되지 않은 기능을 사용할 수 없다는 뜻이다. 내장형 타입과 마찬가지로 대부분의 사용자 정의 타입은 연산을 제공한다.
   - C++에서는 대표적인 사용자 정의 타입으로 Class, Struct, Enum, Union이 있다. 
   
9. 클래스(class)와 구조체(struct)의 차이는? <br>
    - **Class**
      + 일반적으로 객체의 정의를 위해 사용되며, 기본 접근 지정 제어자는 private이다. 클래스는 **프로그램 안에서 특정 개념을 직접적으로 표현하는 사용자 정의 타입**으로, 해당 타입의 객체를 표현하는 방법과 객체를 생성하는 방법, 객체를 사용하는 방법, 객체를 소멸시키는 방법을 명시한다.
        
    - **Struct**
      + 하나 이상의 변수를 묶어 그룹화하는 사용자 정의 타입으로, 기본 접근 제어자는 public이다.

참고로, Class와 Struct는 C++에서는 기본 접근제어자 외에는 거의 동일한 사용자 정의 타입이다. 즉, 구조체 또한 상속이 가능하지만 기본 접근 제어자는 public으로 유지된다. 
보통 struct는 단순한 데이터의 집합으로 사용하는 편이고, class는 데이터와 함께 행위(메서드, 함수)를 포함하는 경우에 사용한다. 

[클래스 및 구조체 C++](https://learn.microsoft.com/ko-kr/cpp/cpp/classes-and-structs-cpp?view=msvc-170)

MS문서를 보면 "**구조체에서는 기본 접근성이 공용(public)이고, 클래스에서는 기본값이 개인(private)이라는 점을** 제외하면 C++에서 **두 구문이 동일**합니다." 라고 나온다. 

10. enum과 enum class의 차이는? <br>
열거형은 왜 사용할까? → 직관적이고, 가독성이 좋기 때문이다.  

   - **enum**
     + 이 또한, 사용자 정의 타입으로, 값(열거자)의 집합을 기호 상수로 정의하는것. 즉, enum으로 구성된 전체의 형태는 **열거형**이라고 하고, 그안에 속하는 데이터들은 **열거자**라고 한다. 일반적으로 대문자를 넣고, 정수 값이 자동 할당될 뿐만이 아니라 양수, 음수 값 모두 가능하다. 만약 값을 명시하지 않을 경우, 0부터 시작된다. 꼭 정수 값을 0으로 시작 안해도 된다. 하지만 enum에서 int로 암시적인 변환이 되지만 반대로 int 에서 enum의 암시적 변환은 불가능하다. 그렇기 떄문에 static_cast 키워드를 사용하여 변환을 해야한다. 단점으로, 값에 정의되지 않은 즉, 범위에서 벗어난 열거자 값이라도, 컴파일러가 되기 때문에 예측하지 못하는 값이 나올 수 있다.  
       
   - **enum class**
     + enum과 큰 차이가 없지만, 기존의 enum을 보완하기 위한, 그리고 상대적으로 더 제약이 있는 사용자 정의 타입이다. enum은 enum영역이 다르더라도, 같은 이림의 변수가 있으면 컴파일러는 해당 변수가 어떤 enum에 속하는 데이터인지 알 수 없어서 별도로 각 enum에 namespace를 만들어서 사용하거나 변수명을 수정하거나, 형변환을 안해도 되는데, 형변환을 암시적으로 해주는 경우등... 이러한 단점들을 보완하기 위해 나왔다.  **열거형 이름::열거자** 형태로 데이터를 호출 할 수 있으며, enum과 달리 **암시적 형변환이 일어나지 않아 명시적인 변환**을 해줘야 한다. 또한, **동일한 변수명에 충돌을 효과적으로 방지할 수 있으며, 범위에서 벗어난 열거자 값이라면 컴파일러가 되지 않는다.** 

그럼 무엇을 사용해야하는가? 사용자가 편한대로... 물론 enum class가 실수 방지하기위해 사용하기 때문에, 실수가 발생하지 않을거라면 사용하지 않아도 된다. 하지만 enum보다는 enum class를 권장한다. 혹은 C++11에서 enum class가 도입되었기 때문에 그전의 C++03, C++98...즉, 레거시 코드라면 enum으로 작성하는 경우가 있다.

11. 공용체(Union)은 무엇인가? <br>
   - 사용자 정의 타입으로, 구조체와 거의 동일하지만, **모든 멤버 변수를 하나의 메모리 공간을 공유한다**라는 특징이 있다. 즉, union으로 선언하면 내부에 여러 가지 타입의 멤버 변수가 있지만, 실제 사용시에는 하나의 멤버 변수로만 사용할 수 있다. 그렇기 때문에 선언한 변수중 가장 크기가 큰 타입의 멤버 변수의 크기가 union의 크기가 된다. 멤버 변수가 여러 가지 타입이 가능할 때, 사용하며 하나의 메모리 공간을 고융하기 때문에 메모리를 효율적으로 사용할 수 있다. 

12. 포인터의 개념은 무엇인가?

13. 스마트 포인터에 대해 설명하고, unique_ptr과 shared_ptr의 차이점은?

14. std::function은 무엇인가?


15. Array와 Vector 그리고 List의 차이는?


-------------------------------------------------------------------

## 2. 자료구조 
   - 2-1. 자료구조 개념
   - 2-2. 선형 구조와 비선형구조의 특징의 특징
